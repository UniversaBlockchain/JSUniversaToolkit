package models

import boss.jsany._
import boss.{BossReader, BossWriter}
import cloud.EncryptionError
import tools.universa.UniversaTools.encode64

import scala.collection.mutable
import scala.collection.mutable.{HashMap, ListBuffer}

/** Contains information about Key and helper to match keys compatibility
  *
  *  @constructor create a new key info object by parameters
  *  @param algorithm the key generator algorithm name
  *  @param tag the key soft identifier (ex. part of fingerprint)
  *  @param prf the name of pseudorandom function of two parameters
  *  @param keyLength the key byte size
  *  @param isPassword flag to identify if key has password
  *. @param rounds number of iterations if key was generated by iterate algorithm
  */
class KeyInfo(
               val algorithm: String,
               val tag: Option[mutable.Seq[Byte]] = None,
               val prf: Option[String] = None,
               val keyLength: Int,
               val isPassword: Boolean,
               val rounds: Option[Int] = None
             ) {
  /** Available key algorithms */
  val ALGORITHMS = ListBuffer("UNKNOWN", "RSA_PUBLIC", "RSA_PRIVATE", "AES256")
  /** Available pseudorandom functions */
  val PRF = ListBuffer("NONE", "HMAC_SHA1", "HMAC_SHA256", "HMAC_SHA512")

  override def toString(): String = {
    val tagStr = tag match {
      case Some(value) => encode64(value)
      case _ => "null"
    }

    if (isPassword) {
      val prfVal = prf.get
      val roundsVal = rounds.get

      s"PBKDF2($prfVal,$roundsVal), $algorithm, tag=$tagStr kLength=$keyLength"
    } else s"$algorithm, tag=$tagStr kLength=$keyLength"
  }

  /** Packs key info to BOSS binary */
  def pack: Seq[Byte] = {
    val writer = new BossWriter()
    val algorithmCode = ALGORITHMS.indexOf(algorithm)
    if (algorithmCode < 0)
      throw new EncryptionError(s"keyinfo: unknown algorithm code $algorithmCode")

    writer.write(algorithmCode)
    val tagCode = tag.orNull

    writer.write(tagCode)

    val prfCode = prf match {
      case Some(value) =>
        val index = PRF.indexOf(value)
        if (index < 0) throw new EncryptionError(s"keyinfo: invalid prf code $index")
        index
      case None => 0
    }

    writer.write(prfCode)
    writer.write(keyLength)

    if (isPassword) {
      writer.write(0)
      writer.write(rounds.get)
    }

    writer.get()
  }

  /** Checks if key info's are compatible */
  def matchType(other: KeyInfo): Boolean = {
    if (keyLength != other.keyLength) return false

    if (algorithm == other.algorithm && algorithm != "RSA_PUBLIC")
      return true

    algorithm == "RSA_PRIVATE" && other.algorithm == "RSA_PUBLIC"
  }
}

/** Factory for [[KeyInfo]] instances. */
object KeyInfo {
  /** Available key algorithms */
  val ALGORITHMS = ListBuffer(
    "UNKNOWN", "RSA_PUBLIC", "RSA_PRIVATE", "AES256"
  )
  /** Available pseudorandom functions */
  val PRF = ListBuffer("NONE", "HMAC_SHA1", "HMAC_SHA256", "HMAC_SHA512")

  /** Creates key info by hashmap of parameters */
  def apply(data: HashMap[String, Any]): KeyInfo = {
    data.get("packed") match {
      case Some(packed) => KeyInfo.fromBinary(packed.asInstanceOf[Seq[Byte]])
      case None => KeyInfo.fromMap(data)
    }
  }

  /** Creates key info by BOSS packed binary */
  def apply(packed: Seq[Byte]): KeyInfo = fromBinary(packed)

  /** Creates key info by BOSS packed binary */
  def fromBinary(data: Seq[Byte]): KeyInfo = {
    val reader = new BossReader(data)
    val algorithmCode = reader.read().asInstanceOf[Int]
    if (algorithmCode >= ALGORITHMS.size)
      throw new EncryptionError(s"keyinfo: unknown algorithm code $algorithmCode")
    val algorithm = ALGORITHMS(algorithmCode)
    val tagGot = reader.read()

    val tag = tagGot match {
      case null => None
      case _ => Some(tagGot.asInstanceOf[Seq[Byte]]).map(a => mutable.Seq(a:_*))
    }

    val prfCode = reader.read().asInstanceOf[Int]
    if (prfCode >= PRF.size)
      throw new EncryptionError(s"keyinfo: invalid prf code $prfCode")
    val prf = PRF(prfCode)
    val keyLength = reader.read().asInstanceOf[Int]
    val isPassword = prfCode != 0
    var rounds: Option[Int] = None

    if (isPassword) {
      val keyType = reader.read()
      if (keyType != 0) {
        throw new EncryptionError(s"keyinfo: unsupported password key type: $keyType")
      }
      rounds = Some(reader.read().asInstanceOf[Int])
    }

    new KeyInfo(algorithm, tag, Some(prf), keyLength, isPassword, rounds)
  }

  /** Creates key info by hashmap of parameters */
  def fromMap(data: HashMap[String, Any]): KeyInfo = {
    val algorithm = data.getOrElse("algorithm",
      throw new EncryptionError(s"keyinfo: algorithm required")
    ).asInstanceOf[String]

    val tagGot = data.get("tag")
    val tag = tagGot.map(_.asInstanceOf[mutable.Seq[Byte]])

    val keyLength = data.getOrElse("keyLength",
      throw new EncryptionError(s"keyinfo: keyLength required")
    ).asInstanceOf[Int]
    val prf = data.get("prf").asInstanceOf[Option[String]]
    val rounds = data.get("rounds").map(_.asInstanceOf[Int])
    val isPassword = prf.isDefined

    new KeyInfo(algorithm, tag, prf, keyLength, isPassword, rounds)
  }
}
