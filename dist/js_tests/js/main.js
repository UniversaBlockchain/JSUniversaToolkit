// Generated by CoffeeScript 2.3.1
(function () {
  var TestCase, Unitest, eq, failed, log, module, passed, print, replace, selfTests, spin, testModules;

  module = typeof window !== "undefined" && window !== null ? window : this;

  Unitest = module.Unitest || (module.Unitest = {});

  selfTests = [];

  testModules = [];

  Unitest.addTest = function (name, callback) {
    return selfTests.push({
      name: name,
      callable: callback
    });
  };

  passed = 0;

  failed = 0;

  Function.prototype.property = function (prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  Unitest.addLog = function (level, ...message) {
    if (level === 'e') {
      return console.error(...message);
    } else {
      return console.log(...message);
    }
  };

  Unitest.log = function (...message) {
    return Unitest.addLog('d', ...message);
  };

  log = function (...args) {
    return Chatle.log(...args);
  };

  print = function (msg) {
    var container;
    container = document.querySelector("#main");
    return container.innerHTML += "<p>" + msg + "</p>";
  };

  replace = function (msg) {
    var container;
    container = document.querySelector("#main");
    container.removeChild(container.lastChild);
    return container.innerHTML += "<p>" + msg + "</p>";
  };

  spin = function () {
    var a, idx, nextSym, spinner;
    spinner = document.querySelector(".spinner");
    a = ['-', '\\', '|', '/'];
    if (spinner) {
      idx = a.indexOf(spinner.innerHTML);
      nextSym = idx === a.length - 1 ? 0 : idx + 1;
      spinner.innerHTML = a[nextSym];
    }
    return setTimeout(spin, 50);
  };

  eq = function (a, b) {
    if (a != null ? a.equals : void 0) {
      return a.equals(b);
    }
    if (b != null ? b.equals : void 0) {
      return b.equals(a);
    }
    return a === b;
  };

  TestCase = {
    assertEquals: function (expected, found, msg) {
      if (!eq(expected, found)) {
        if (msg) {
          msg = `\n\tin: ${msg}`;
        }
        throw `expected ${found} to be equal to ${expected}` + (msg || '');
      }
    },
    assertNull: function (value) {
      if (value !== null) {
        throw `expected ${value} to be null`;
      }
    },
    assertNotNull: function (value, text = null) {
      if (value === null) {
        throw text || "expected not null";
      }
    },
    assertTrue: function (value, text) {
      if (value !== true) {
        throw text || `expected ${value} to be true`;
      }
    },
    assertTruthy: function (value, text = null) {
      if (!value) {
        throw text || `expected ${value} to be truthy`;
      }
    },
    assertFalse: function (value) {
      if (value !== false) {
        throw `expected ${value} to be false`;
      }
    },
    assertFalsey: function (value, text) {
      if (value) {
        throw text || `expected ${value} to be falsey`;
      }
    },
    assertThrows: async function (klass, block) {
      var exception, failure;
      failure = null;
      try {
        await block();
        failure = `expected exception ${klass} but nothing was thrown`;
      } catch (error) {
        exception = error;
        if (klass && !(exception instanceof klass)) {
          failure = `expected exception ${klass} but ${exception} was thrown`;
        }
      }
      if (failure) {
        throw failure;
      }
    },
    assert: function (condition) {
      if (!condition) {
        throw "assertion failed";
      }
    }
  };

  //  assertIncludes: (collection, item) ->
  //    if collection.indexOf(item) < 0
  //      throw "expected #{collection}\n to include #{item}"
  Unitest.test = window.unitjs;

  Unitest.addTestModule = function (module) {
    return testModules.push(module);
  };

  Unitest.runTests = function ({ except = null, only = null } = {}) {
    var i, len, m;
    spin();
    for (i = 0, len = testModules.length; i < len; i++) {
      m = testModules[i];
      m();
    }
    return new Promise(async function (resolve, reject) {
      var exception, j, len1, result, test, testCase;
      testCase = TestCase;
      for (j = 0, len1 = selfTests.length; j < len1; j++) {
        test = selfTests[j];
        try {
          if (only && test.name !== only) {
            continue;
          }
          if (except && test.name.match(except)) {
            print("== skipping test:" + test.name);
            continue;
          }
          print(`-- test ${test.name}: running <span class='spinner'>|</span>`);
          result = test.callable.apply(testCase);
          if (result instanceof Promise) {
            await result;
          }
          replace(`++ test ${test.name}: passed`);
          passed++;
        } catch (error) {
          exception = error;
          console.error(exception);
          if (exception.stack) {
            console.error(exception.stack);
          }
          replace(`!! ${test.name} FAILED`);
          failed++;
        }
      }
      print(`** Done executing ChatleUniversa tests, passed ${passed}, failed: ${failed}`);
      print(`** ChatleUniversa test is ${failed > 0 ? 'FAILED' : 'passed'}`);
      if (failed === 0) {
        return resolve();
      } else {
        return reject();
      }
    });
  };

  Unitest.addTest('new testing system', function () {
    return this.assertEquals(5, 2 * 2 + 1);
  });
}).call(this);